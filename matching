import discord
from discord.ext import commands
from discord import app_commands
import os
import random
from dotenv import load_dotenv
import asyncio
import datetime
from typing import Dict, Set, Tuple, List

# --- Environment Variables ---
load_dotenv()
TOKEN = os.getenv('DISCORD_TOKEN')

# --- Configuration ---
SOURCE_CHANNEL_GIRLS_NAME = "女子回答"
SOURCE_CHANNEL_BOYS_NAME = "男子回答"
TARGET_CHANNEL_GIRLS_NAME = "女子選択"
TARGET_CHANNEL_BOYS_NAME = "男子選択"

# Role IDs for users allowed to react/select
ALLOWED_ROLE_IDS: Set[int] = {
    1106457108070801449,  # 例: 男子用ロールID
    1304664940019187762   # 例: 女子用ロールID
}

# Role ID allowed to execute /send1, /match, /reset etc.
EXECUTE_ROLE_ID = 991112832655560825  # 例: 管理者用役職ID

# Voice Channel IDs for matched pairs
VOICE_CHANNEL_IDS = [
    861209035901501451, 921389966939000842, 861209625353650176, 1144961582158315601,
    1346803272094191616, 1144961845891969086, 1346803325705916470, 1030459649952055326,
    861209735826898954, 889128948225679410, 1124346578522607667, 1076820944896675931,
    1129391099354546249, 1129391139905097768, 1165525003165515847, 1165611161887191070,
    1165525074317676615, 1165606798577901648, 1165606801547464765, 1165606820178567220,
    1165606757788307506, 1238860655683960853,
]

# Waiting Voice Channel ID (ユーザーが選択する際の待機VC)
WAITING_VOICE_CHANNEL_ID = 1059809361645551746

# --- Bot Setup ---
intents = discord.Intents.default()
intents.messages = True
intents.guilds = True
intents.message_content = True
intents.reactions = True
intents.members = True

bot = commands.Bot(command_prefix="!", intents=intents)

# --- Global State Variables ---
source_channel_girls: discord.TextChannel = None
source_channel_boys: discord.TextChannel = None
target_channel_girls: discord.TextChannel = None
target_channel_boys: discord.TextChannel = None
forwarded_message_ids: Dict[int, Set[int]] = {}
message_map: Dict[int, Tuple[int, int, int]] = {}  # {original_message_id: (forwarded_message_id, destination_channel_id, original_author_id)}
active_claimable_messages: Set[int] = set()
claimed_messages: Dict[int, int] = {}  # {forwarded_message_id: claimer_id}
users_who_claimed_this_round: Set[int] = set()
matched_pairs: Set[int] = set()
current_match_channel_index: int = 0
bot_start_time: datetime.datetime = None
last_non_winner_message_boys_id: int = None
last_non_winner_message_girls_id: int = None

# --- Custom Check ---
def allowed_role_check(interaction: discord.Interaction) -> bool:
    """EXECUTE_ROLE_IDを持つ人のみ実行可"""
    return any(role.id == EXECUTE_ROLE_ID for role in interaction.user.roles)

# ------------------------------------------------------
# ★★★修正ポイント★★★
# 未当選者リストを「削除→新規投稿」ではなく
# 「既存メッセージがあれば編集、なければ新規投稿」する関数に変更
# ------------------------------------------------------
async def post_list_message(channel: discord.TextChannel, content: str, old_message_id: int) -> Tuple[int, List[str]]:
    """
    既存メッセージを編集し、存在しなければ新規送信する。
    戻り値: (最終的に存在するメッセージID, エラーリスト)
    """
    errors = []
    new_message_id = None
    if not channel:
        errors.append("エラー: 対象チャンネルが見つかりません。")
        return None, errors

    # 1) old_message_id があれば編集を試みる
    if old_message_id:
        try:
            old_msg = await channel.fetch_message(old_message_id)
            # メッセージの編集
            await old_msg.edit(content=content)
            new_message_id = old_msg.id
            return new_message_id, errors  # 編集成功なので終了
        except discord.NotFound:
            # 存在しなかった場合は新規送信へ
            pass
        except discord.Forbidden:
            errors.append(f"警告: チャンネル '{channel.name}' のメッセージを編集する権限がありません。")
        except Exception as e:
            errors.append(f"編集時エラー({channel.name}): {e}")

    # 2) 新規送信
    try:
        sent_msg = await channel.send(content)
        new_message_id = sent_msg.id
    except discord.Forbidden:
        errors.append(f"エラー: チャンネル '{channel.name}' への送信権限がありません。")
    except Exception as e:
        errors.append(f"送信時エラー({channel.name}): {e}")

    return new_message_id, errors

# --- Calculate Non-Winner List Content ---
async def calculate_non_winner_content(guild: discord.Guild) -> Tuple[str, str, List[str]]:
    """
    未当選者リストの内容を計算する。
    「未当選」かつ「待機VCに接続している」メンバーのみ表示。
    """
    global target_channel_boys, target_channel_girls, message_map, claimed_messages
    calc_errors: List[str] = []

    role_girls_id = 1304664940019187762  # 女子用ロールID
    role_boys_id = 1106457108070801449   # 男子用ロールID

    role_girls = guild.get_role(role_girls_id)
    role_boys = guild.get_role(role_boys_id)

    winners_girls = set()
    winners_boys = set()

    # 当選済みユーザーをセットに入れる
    for fwd_id, claimer_id in claimed_messages.items():
        original_author_id = None
        dest_channel_id = None
        found = False
        for _orig_id, (fwd_id_map, dest_channel_id_map, original_author_id_map) in message_map.items():
            if fwd_id_map == fwd_id:
                original_author_id = original_author_id_map
                dest_channel_id = dest_channel_id_map
                found = True
                break
        if not found:
            calc_errors.append(f"転送ID {fwd_id} のマッピングが見つかりません。")
            continue

        if target_channel_boys and dest_channel_id == target_channel_boys.id:
            winners_boys.add(claimer_id)
            winners_girls.add(original_author_id)
        elif target_channel_girls and dest_channel_id == target_channel_girls.id:
            winners_girls.add(claimer_id)
            winners_boys.add(original_author_id)
        else:
            calc_errors.append(f"転送先チャンネルID {dest_channel_id} が不明です。")

    # 男子の未当選者(かつ待機VC接続中)
    non_winners_boys = []
    if role_boys:
        for m in role_boys.members:
            if (m.id not in winners_boys
                and m.voice
                and m.voice.channel
                and m.voice.channel.id == WAITING_VOICE_CHANNEL_ID):
                non_winners_boys.append(m.mention)

    # 女子の未当選者(かつ待機VC接続中)
    non_winners_girls = []
    if role_girls:
        for m in role_girls.members:
            if (m.id not in winners_girls
                and m.voice
                and m.voice.channel
                and m.voice.channel.id == WAITING_VOICE_CHANNEL_ID):
                non_winners_girls.append(m.mention)

    content_boys = "【男子 未当選者一覧】\n" + (", ".join(non_winners_boys) if non_winners_boys else "なし")
    content_girls = "【女子 未当選者一覧】\n" + (", ".join(non_winners_girls) if non_winners_girls else "なし")

    return content_boys, content_girls, calc_errors

@bot.event
async def on_ready():
    global source_channel_girls, source_channel_boys
    global target_channel_girls, target_channel_boys
    global forwarded_message_ids, bot_start_time

    print(f'{bot.user.name} としてログイン (ID: {bot.user.id})')
    bot_start_time = datetime.datetime.now(datetime.timezone.utc)

    try:
        synced = await bot.tree.sync()
        print(f"{len(synced)}個のスラッシュコマンドを同期しました。")
    except Exception as e:
        print(f"コマンド同期エラー: {e}")

    if not bot.guilds:
        print("エラー: 参加サーバーがありません。")
        await bot.close()
        return

    guild = bot.guilds[0]
    source_channel_girls = discord.utils.get(guild.text_channels, name=SOURCE_CHANNEL_GIRLS_NAME)
    source_channel_boys = discord.utils.get(guild.text_channels, name=SOURCE_CHANNEL_BOYS_NAME)
    target_channel_girls = discord.utils.get(guild.text_channels, name=TARGET_CHANNEL_GIRLS_NAME)
    target_channel_boys = discord.utils.get(guild.text_channels, name=TARGET_CHANNEL_BOYS_NAME)

    if not all([source_channel_girls, source_channel_boys, target_channel_girls, target_channel_boys]):
        print("必要なチャンネルが見つかりません。")
    else:
        forwarded_message_ids = {
            source_channel_girls.id: set(),
            source_channel_boys.id: set()
        }
    print("Bot準備完了。")

@bot.event
async def on_message_edit(before: discord.Message, after: discord.Message):
    """
    転送元メッセージが編集された場合、転送先も同様に編集する。
    ※ claimed_messages かどうかに関わらず常に更新
    """
    if before.author.bot or before.id not in message_map:
        return

    forwarded_message_id, destination_channel_id, _ = message_map[before.id]
    destination_channel = bot.get_channel(destination_channel_id)
    if not destination_channel or not isinstance(destination_channel, discord.TextChannel):
        return

    try:
        f_msg = await destination_channel.fetch_message(forwarded_message_id)
    except discord.NotFound:
        # 転送先メッセージが既に消されている場合など
        return
    except Exception as e:
        print(f"[on_message_edit] 転送先メッセージ取得エラー: {e}")
        return

    new_content = after.content if after.content else "(本文なし)"
    try:
        if f_msg.embeds:
            new_embed = f_msg.embeds[0].copy()
            new_embed.description = new_content
            await f_msg.edit(embed=new_embed)
        else:
            await f_msg.edit(content=new_content)
    except Exception as e:
        print(f"[on_message_edit] 転送先更新エラー: {e}")


@bot.event
async def on_message_delete(message: discord.Message):
    """
    転送元メッセージが削除されたら、転送先も削除する。
    """
    global last_non_winner_message_boys_id, last_non_winner_message_girls_id

    if message.author.bot or message.id not in message_map:
        return

    # 転送先メッセージ情報を取得して削除
    forwarded_message_id, destination_channel_id, _ = message_map.pop(message.id)
    destination_channel = bot.get_channel(destination_channel_id)

    active_claimable_messages.discard(forwarded_message_id)
    if forwarded_message_id in claimed_messages:
        claimer_id = claimed_messages.pop(forwarded_message_id)
        users_who_claimed_this_round.discard(claimer_id)
        matched_pairs.discard(forwarded_message_id)

    if destination_channel and isinstance(destination_channel, discord.TextChannel):
        try:
            f_msg = await destination_channel.fetch_message(forwarded_message_id)
            await f_msg.delete()
        except discord.NotFound:
            pass
        except Exception as e:
            print(f"[on_message_delete] 転送先メッセージ削除エラー: {e}")

    # 未当選者リスト再掲
    try:
        if message.guild:
            content_boys, content_girls, calc_errors = await calculate_non_winner_content(message.guild)
            if calc_errors:
                for err in calc_errors:
                    print(f"[on_message_delete] リスト更新計算エラー: {err}")

            if target_channel_boys and any(v[1] == target_channel_boys.id for v in message_map.values()):
                new_id, errors = await post_list_message(target_channel_boys, content_boys, last_non_winner_message_boys_id)
                if new_id:
                    last_non_winner_message_boys_id = new_id
                for err in errors:
                    print(f"[on_message_delete] 男子未当選リスト投稿エラー: {err}")

            if target_channel_girls and any(v[1] == target_channel_girls.id for v in message_map.values()):
                new_id, errors = await post_list_message(target_channel_girls, content_girls, last_non_winner_message_girls_id)
                if new_id:
                    last_non_winner_message_girls_id = new_id
                for err in errors:
                    print(f"[on_message_delete] 女子未当選リスト投稿エラー: {err}")

    except Exception as e:
        print(f"[on_message_delete] 未当選者リスト再更新エラー: {e}")

@bot.event
async def on_raw_reaction_add(payload: discord.RawReactionActionEvent):
    global last_non_winner_message_boys_id, last_non_winner_message_girls_id
    if payload.user_id == bot.user.id or str(payload.emoji) != '👍':
        return

    guild = bot.get_guild(payload.guild_id)
    if not guild:
        return
    channel = guild.get_channel(payload.channel_id)
    if not isinstance(channel, discord.TextChannel):
        return

    try:
        message = await channel.fetch_message(payload.message_id)
    except Exception as e:
        print(f"リアクションメッセージ取得エラー: {e}")
        return

    member = payload.member or (await guild.fetch_member(payload.user_id))
    if payload.message_id not in active_claimable_messages:
        return

    # 条件を満たさない場合、リアクション除去して終了
    if (
        payload.message_id in claimed_messages or
        payload.user_id in users_who_claimed_this_round or
        not (member.voice and member.voice.channel and member.voice.channel.id == WAITING_VOICE_CHANNEL_ID) or
        not any(role.id in ALLOWED_ROLE_IDS for role in member.roles)
    ):
        try:
            await message.remove_reaction(payload.emoji, member)
        except:
            pass
        return

    # Claim
    claimed_messages[payload.message_id] = payload.user_id
    users_who_claimed_this_round.add(payload.user_id)
    active_claimable_messages.remove(payload.message_id)

    try:
        await message.clear_reaction('👍')
        await message.add_reaction('✅')
        if message.embeds:
            new_embed = message.embeds[0].copy()
            selector_index = -1
            for i, field in enumerate(new_embed.fields):
                if field.name == "選択者":
                    selector_index = i
                    break
            if selector_index != -1:
                new_embed.set_field_at(selector_index, name="選択者", value=f"✅ {member.mention}", inline=False)
            else:
                new_embed.add_field(name="選択者", value=f"✅ {member.mention}", inline=False)
            await message.edit(embed=new_embed)
        else:
            await message.edit(content=message.content + f"\n✅ {member.mention} さんが選択しました！")

        # 未当選者リスト更新
        content_boys, content_girls, calc_errors = await calculate_non_winner_content(guild)
        if calc_errors:
            print(f"リアクション時リスト計算エラー: {calc_errors}")

        if target_channel_boys and any(v[1] == target_channel_boys.id for v in message_map.values()):
            new_id, errors = await post_list_message(target_channel_boys, content_boys, last_non_winner_message_boys_id)
            if new_id:
                last_non_winner_message_boys_id = new_id

        if target_channel_girls and any(v[1] == target_channel_girls.id for v in message_map.values()):
            new_id, errors = await post_list_message(target_channel_girls, content_girls, last_non_winner_message_girls_id)
            if new_id:
                last_non_winner_message_girls_id = new_id

    except Exception as e:
        print(f"リアクション更新エラー: {e}")
        # ロールバック
        claimed_messages.pop(payload.message_id, None)
        users_who_claimed_this_round.discard(payload.user_id)
        active_claimable_messages.add(payload.message_id)

@bot.tree.command(name="send1", description="回答を転送し、未当選者リストを更新")
@app_commands.check(allowed_role_check)
async def send_messages(interaction: discord.Interaction):
    global forwarded_message_ids, message_map, active_claimable_messages
    global last_non_winner_message_boys_id, last_non_winner_message_girls_id

    if not all([source_channel_girls, source_channel_boys, target_channel_girls, target_channel_boys]):
        await interaction.response.send_message("エラー: 必要なチャンネルが設定されていません。", ephemeral=True)
        return

    await interaction.response.defer(ephemeral=True)
    total_forwarded_count = 0
    error_messages_list: List[str] = []

    async def process_channel(source_channel: discord.TextChannel,
                              target_channel: discord.TextChannel,
                              embed_color: discord.Color) -> int:
        nonlocal total_forwarded_count
        count = 0
        try:
            source_messages = []
            async for msg in source_channel.history(limit=None, after=bot_start_time):
                if (not msg.author.bot and
                    msg.id not in forwarded_message_ids.get(source_channel.id, set()) and
                    msg.id not in message_map and (msg.content or msg.attachments)):
                    source_messages.append(msg)

            random.shuffle(source_messages)
            for orig_msg in source_messages:
                try:
                    embed = discord.Embed(
                        description=orig_msg.content if orig_msg.content else "(本文なし)",
                        color=embed_color,
                        timestamp=orig_msg.created_at
                    )

                    image_url = None
                    for att in orig_msg.attachments:
                        if att.content_type and att.content_type.startswith('image/'):
                            image_url = att.url
                            break
                    if image_url:
                        embed.set_image(url=image_url)

                    others = [att.filename for att in orig_msg.attachments if att.url != image_url]
                    if others:
                        embed.add_field(name="添付ファイル", value="\n".join(f"- {name}" for name in others), inline=False)

                    embed.add_field(name="選択者", value="なし", inline=False)

                    fwd_msg = await target_channel.send(embed=embed)
                    await fwd_msg.add_reaction("👍")

                    forwarded_message_ids[source_channel.id].add(orig_msg.id)
                    message_map[orig_msg.id] = (fwd_msg.id, target_channel.id, orig_msg.author.id)
                    active_claimable_messages.add(fwd_msg.id)
                    count += 1
                    await asyncio.sleep(0.5)
                except Exception as e:
                    error_messages_list.append(f"転送中エラー (ID:{orig_msg.id}): {e}")
            return count

        except Exception as e:
            error_messages_list.append(f"{source_channel.name} 処理中エラー: {e}")
            return count

    # 女子回答 -> 男子選択 (color=fuchsia)
    count_g = await process_channel(source_channel_girls, target_channel_boys, discord.Color.fuchsia())
    # 男子回答 -> 女子選択 (color=blue)
    count_b = await process_channel(source_channel_boys, target_channel_girls, discord.Color.blue())
    total_forwarded_count = count_g + count_b

    if total_forwarded_count > 0 and interaction.guild:
        content_boys, content_girls, calc_errors = await calculate_non_winner_content(interaction.guild)
        error_messages_list.extend(calc_errors)

        if target_channel_boys and any(v[1] == target_channel_boys.id for v in message_map.values()):
            new_id, post_err = await post_list_message(target_channel_boys, content_boys, last_non_winner_message_boys_id)
            if new_id:
                last_non_winner_message_boys_id = new_id
            error_messages_list.extend(post_err)

        if target_channel_girls and any(v[1] == target_channel_girls.id for v in message_map.values()):
            new_id, post_err = await post_list_message(target_channel_girls, content_girls, last_non_winner_message_girls_id)
            if new_id:
                last_non_winner_message_girls_id = new_id
            error_messages_list.extend(post_err)
    else:
        print("転送されたメッセージが0件のため、未当選者リストの更新をスキップします。")

    result_msg = f"合計 {total_forwarded_count} 件の新規転送完了。"
    if error_messages_list:
        result_msg += "\nエラー/警告:\n" + "\n".join(f"{i+1}. {msg}" for i, msg in enumerate(error_messages_list))
    else:
        result_msg += "\n未当選者リストを更新しました。"

    await interaction.followup.send(result_msg, ephemeral=True)


@bot.tree.command(name="match", description="ペア移動＆状態リセット＆リスト更新")
@app_commands.check(allowed_role_check)
async def match_all(interaction: discord.Interaction):
    global current_match_channel_index, matched_pairs
    global forwarded_message_ids, message_map, active_claimable_messages
    global claimed_messages, users_who_claimed_this_round
    global last_non_winner_message_boys_id, last_non_winner_message_girls_id
    global source_channel_girls, source_channel_boys, target_channel_boys, target_channel_girls

    await interaction.response.defer(ephemeral=True)
    moved_count = 0
    error_messages_list: List[str] = []

    guild = interaction.guild
    if not guild:
        await interaction.followup.send("サーバー情報取得エラー", ephemeral=True)
        return

    items = list(message_map.items())
    for orig_id, (fwd_id, dest_id, orig_author_id) in items:
        # 未選択 or 既にmatch済みのものはスキップ
        if fwd_id not in claimed_messages or fwd_id in matched_pairs:
            continue

        claimer_id = claimed_messages[fwd_id]
        pair_boy = None
        pair_girl = None
        target_txt = guild.get_channel(dest_id)

        # チャンネルIDを見て投稿者を男女判定
        try:
            if target_txt and dest_id == target_channel_boys.id:
                pair_girl = await guild.fetch_member(orig_author_id)
                pair_boy = await guild.fetch_member(claimer_id)
            elif target_txt and dest_id == target_channel_girls.id:
                pair_boy = await guild.fetch_member(orig_author_id)
                pair_girl = await guild.fetch_member(claimer_id)
            else:
                continue
        except Exception as e:
            error_messages_list.append(f"ペア取得エラー (origMsgID:{orig_id}): {e}")
            continue

        # 待機VCにいないならスキップ
        if not (pair_boy and pair_boy.voice and pair_boy.voice.channel and pair_boy.voice.channel.id == WAITING_VOICE_CHANNEL_ID):
            error_messages_list.append(f"{pair_boy.display_name} 待機VC未在中 (origMsgID:{orig_id})")
            continue
        if not (pair_girl and pair_girl.voice and pair_girl.voice.channel and pair_girl.voice.channel.id == WAITING_VOICE_CHANNEL_ID):
            error_messages_list.append(f"{pair_girl.display_name} 待機VC未在中 (origMsgID:{orig_id})")
            continue

        # VC移動
        if current_match_channel_index >= len(VOICE_CHANNEL_IDS):
            error_messages_list.append("利用可能なVCが足りません。")
            break

        target_vc = guild.get_channel(VOICE_CHANNEL_IDS[current_match_channel_index])
        if not target_vc or not isinstance(target_vc, discord.VoiceChannel):
            error_messages_list.append(f"移動先VCが不正 (ID:{VOICE_CHANNEL_IDS[current_match_channel_index]})")
            continue

        try:
            await pair_boy.move_to(target_vc)
            await pair_girl.move_to(target_vc)
            matched_pairs.add(fwd_id)
            current_match_channel_index += 1
            moved_count += 1
        except Exception as e:
            error_messages_list.append(f"VC移動エラー ({target_vc.name}): {e}")
            continue

        # Embed更新(「状態」「回答者」を追記)
        try:
            if target_txt:
                f_msg = await target_txt.fetch_message(fwd_id)
                if f_msg.embeds:
                    new_embed = f_msg.embeds[0].copy()
                    # 状態フィールド
                    status_idx = -1
                    for i, field in enumerate(new_embed.fields):
                        if field.name == "状態":
                            status_idx = i
                            break
                    status_val = f"✅ 移動完了 ({target_vc.mention})"
                    if status_idx != -1:
                        new_embed.set_field_at(status_idx, name="状態", value=status_val, inline=False)
                    else:
                        new_embed.add_field(name="状態", value=status_val, inline=False)

                    # 回答者フィールド
                    answerer_idx = -1
                    for i, field in enumerate(new_embed.fields):
                        if field.name == "回答者":
                            answerer_idx = i
                            break
                    if dest_id == target_channel_boys.id:
                        answerer_val = f"{pair_girl.mention}"
                    else:
                        answerer_val = f"{pair_boy.mention}"

                    if answerer_idx != -1:
                        new_embed.set_field_at(answerer_idx, name="回答者", value=answerer_val, inline=False)
                    else:
                        new_embed.add_field(name="回答者", value=answerer_val, inline=False)

                    await f_msg.edit(embed=new_embed)

        except Exception as e:
            error_messages_list.append(f"Embed更新警告 (FwdMsgID:{fwd_id}): {e}")

        await asyncio.sleep(0.5)

    # --- 状態リセット ---
    try:
        forwarded_message_ids = {source_channel_girls.id: set(), source_channel_boys.id: set()}
        message_map.clear()
        active_claimable_messages.clear()
        claimed_messages.clear()
        users_who_claimed_this_round.clear()
        matched_pairs.clear()
        current_match_channel_index = 0
        last_non_winner_message_boys_id = None
        last_non_winner_message_girls_id = None
    except Exception as e:
        error_messages_list.append(f"状態リセットエラー: {e}")

    # 未当選者リスト再更新
    try:
        content_boys, content_girls, calc_errors = await calculate_non_winner_content(guild)
        error_messages_list.extend(calc_errors)

        if target_channel_boys and any(v[1] == target_channel_boys.id for v in message_map.values()):
            new_id, errs = await post_list_message(target_channel_boys, content_boys, last_non_winner_message_boys_id)
            if new_id:
                last_non_winner_message_boys_id = new_id
            error_messages_list.extend(errs)

        if target_channel_girls and any(v[1] == target_channel_girls.id for v in message_map.values()):
            new_id, errs = await post_list_message(target_channel_girls, content_girls, last_non_winner_message_girls_id)
            if new_id:
                last_non_winner_message_girls_id = new_id
            error_messages_list.extend(errs)

    except Exception as e:
        error_messages_list.append(f"リスト更新後エラー: {e}")

    resp = f"ペア移動 {moved_count} 組完了。"
    if error_messages_list:
        resp += "\nエラー/警告:\n" + "\n".join(f"{i+1}. {msg}" for i, msg in enumerate(error_messages_list))
    else:
        resp += "\n状態リセット・リスト更新完了。"

    await interaction.followup.send(resp, ephemeral=True)


@bot.tree.command(name="reset", description="途中でトラブルがあった場合などに、強制的に状態をリセットします")
@app_commands.check(allowed_role_check)
async def reset_command(interaction: discord.Interaction):
    """
    転送されたメッセージをすべて消去し、内部管理用の状態も初期化する。
    """
    # ここで使うグローバル変数を先に宣言
    global forwarded_message_ids, message_map, active_claimable_messages
    global claimed_messages, users_who_claimed_this_round, matched_pairs
    global current_match_channel_index
    global last_non_winner_message_boys_id, last_non_winner_message_girls_id
    global source_channel_girls, source_channel_boys

    await interaction.response.defer(ephemeral=True)

    error_messages_list: List[str] = []
    guild = interaction.guild
    if not guild:
        await interaction.followup.send("サーバー情報取得エラー", ephemeral=True)
        return

    # 1) 転送先メッセージを一括削除（不要ならコメントアウト）
    try:
        for orig_id, (fwd_id, dest_id, _orig_author) in list(message_map.items()):
            channel = bot.get_channel(dest_id)
            if channel and isinstance(channel, discord.TextChannel):
                try:
                    msg = await channel.fetch_message(fwd_id)
                    await msg.delete()
                except discord.NotFound:
                    pass
                except Exception as e:
                    error_messages_list.append(f"転送先メッセージ削除エラー (ID:{fwd_id}): {e}")
    except Exception as e:
        error_messages_list.append(f"一括削除中エラー: {e}")

    # 2) 各種状態をクリア
    try:
        forwarded_message_ids = {
            source_channel_girls.id: set(),
            source_channel_boys.id: set()
        } if (source_channel_girls and source_channel_boys) else {}
        message_map.clear()
        active_claimable_messages.clear()
        claimed_messages.clear()
        users_who_claimed_this_round.clear()
        matched_pairs.clear()
        current_match_channel_index = 0
        last_non_winner_message_boys_id = None
        last_non_winner_message_girls_id = None
    except Exception as e:
        error_messages_list.append(f"状態初期化中エラー: {e}")

    # 3) 最終結果を返信
    if error_messages_list:
        result_msg = "リセット完了（警告あり）:\n" + "\n".join(f"{i+1}. {m}" for i, m in enumerate(error_messages_list))
    else:
        result_msg = "すべての状態をリセットしました。"

    await interaction.followup.send(result_msg, ephemeral=True)


# --- Bot Execution ---
if TOKEN:
    try:
        print("Bot起動中...")
        bot.run(TOKEN)
    except discord.LoginFailure:
        print("トークンエラー")
    except Exception as e:
        print(f"起動エラー: {e}")
else:
    print("DISCORD_TOKEN 未設定")
